# -*- coding: utf-8 -*-
"""Actividad listas dobles.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14hX3hyA_Qsg9pqi-JY76CMeq3wCiYwih
"""

class Node:
    def __init__(self, data):
        self.item = data
        self.nref = None
        self.pref = None

class DoublyLinkedList:
    def __init__(self):
        self.start_node = None
        
    ###Insertar elementos en una lista vacía
    def insert_in_emptylist(self, data):
        if self.start_node is None:
            new_node = Node(data)
            self.start_node = new_node
        else:
            print("list is not empty") 
    
    ###Insertar datos al inicio de la lista
    def insert_at_start(self, data):
        if self.start_node is None:
            new_node = Node(data)
            self.start_node = new_node
            print("node inserted")
            return
        new_node = Node(data)
        new_node.nref = self.start_node
        self.start_node.pref = new_node
        self.start_node = new_node

    def insert_at_end(self, data):
        if self.start_node is None:
            new_node = Node(data)
            self.start_node = new_node
            return
        n = self.start_node
        while n.nref is not None:
            n = n.nref
        new_node = Node(data)
        n.nref = new_node
        new_node.pref = n
        
    ###Insertar un elemento después de un nodo
    def insert_after_item(self, x, data):
        if self.start_node is None:
            print("List is empty")
            return
        else:
            n = self.start_node
            while n is not None:
                if n.item == x:
                    break
                n = n.nref
            if n is None:
                print("item not in the list")
            else:
                new_node = Node(data)
                new_node.pref = n
                new_node.nref = n.nref
                if n.nref is not None:
                    n.nref.prev = new_node
                n.nref = new_node

    def insert_before_item(self, x, data):
        if self.start_node is None:
            print("List is empty")
            return
        else:
            n = self.start_node
            while n is not None:
                if n.item == x:
                    break
                n = n.nref
            if n is None:
                print("item not in the list")
            else:
                new_node = Node(data)
                new_node.nref = n
                new_node.pref = n.pref
                if n.pref is not None:
                    n.pref.nref = new_node
                n.pref = new_node
                
    ###recorrer una lista doble            
    def traverse_list(self):
        if self.start_node is None:
            print("List has no element")
            return
        else:
            n = self.start_node
            while n is not None:
                print(n.item , " ")
                n = n.nref    

    def delete_at_start(self):
        if self.start_node is None:
            print("The list has no element to delete")
            return 
        if self.start_node.nref is None:
            self.start_node = None
            return
        self.start_node = self.start_node.nref
        self.start_prev = None;
    
    ###Eliminar elementos al final de la lista
    def delete_at_end(self):
        if self.start_node is None:
            print("The list has no element to delete")
            return 
        if self.start_node.nref is None:
            self.start_node = None
            return
        n = self.start_node
        while n.nref is not None:
            n = n.nref
        n.pref.nref = None   

    def delete_element_by_value(self, x):
        if self.start_node is None:
            print("The list has no element to delete")
            return 
        if self.start_node.nref is None:
            if self.start_node.item == x:
                self.start_node = None
            else:
                print("Item not found")
            return 

        if self.start_node.item == x:
            self.start_node = self.start_node.nref
            self.start_node.pref = None
            return

        n = self.start_node
        while n.nref is not None:
            if n.item == x:
                break;
            n = n.nref
        if n.nref is not None:
            n.pref.nref = n.nref
            n.nref.pref = n.pref
        else:
            if n.item == x:
                n.pref.nref = None
            else:
                print("Element not found")

    def reverse_linked_list(self):
        if self.start_node is None:
            print("The list has no element to delete")
            return 
        p = self.start_node
        q = p.nref
        p.nref = None
        p.pref = q
        while q is not None:
            q.pref = q.nref
            q.nref = p
            p = q
            q = q.pref
        self.start_node = p

#1. Crear un método o una función en Python para ordenar una lista doblemente enlazada       

    def sort_list(self):
        if self.start_node is None:
            print("The list has no element to sort")
            return

        end = None
        while end != self.start_node:
            n = self.start_node
            while n.nref != end:
                if n.item > n.nref.item:
                    temp = n.item
                    n.item = n.nref.item
                    n.nref.item = temp
                n = n.nref
            end = n



print("Crear un método o una función en Python para ordenar una lista doblemente enlazada")

dllist = DoublyLinkedList()

# Agregar elementos a la lista
dllist.insert_at_end(5)
dllist.insert_at_end(9)
dllist.insert_at_end(2)
dllist.insert_at_end(6)
dllist.insert_at_end(2)

# Imprimir la lista sin ordenar
print("Lista sin ordenar:")
dllist.traverse_list()

# Ordenar la lista
dllist.sort_list()

# Imprimir la lista ordenada
print("Lista ordenada:")
dllist.traverse_list()         
    

#2. Modificar el valor de un dato en una lista doble dada la información de su índice.

def update_at_index(self, index, data):
        if self.start_node is None:
            print("List is empty")
            return
        else:
            n = self.start_node
            i = 0
            while n is not None:
                if i == index:
                    n.item = data
                    print("Value updated at index ", index)
                    return
                n = n.nref
                i += 1
            print("Index out of range")

print("Modificar el valor de un dato en una lista doble dada la información de su índice.")


# Modificar el valor del segundo elemento (índice 1)
update_at_index(dllist, 1, 8)

# Imprimir la lista después de modificar el dato
print("Lista después de modificar dato:")
dllist.traverse_list()

#3. Eliminar las repeticiones de una lista doble, dejando sólo un valor por muestra.

def remove_duplicates(self):
    if self.start_node is None:
        print("List has no element")
        return
    else:
        n = self.start_node
        seen_items = set([n.item])
        while n.nref is not None:
            item = n.nref.item
            if item not in seen_items:
                seen_items.add(item)
                n = n.nref
            else:
                n.nref = n.nref.nref
                if n.nref is not None:
                    n.nref.pref = n

print("Eliminar las repeticiones de una lista doble, dejando sólo un valor por muestra.")


# Eliminamos los elementos repetidos
remove_duplicates(dllist)

# Imprimimos la lista resultante sin repeticiones
print("Lista sin repeticiones:")
dllist.traverse_list()



#4. Se tiene una lista con diferentes tipos de datos. Eliminar los datos de tipo string y dejar solamente los datos númericos.

print("Se tiene una lista con diferentes tipos de datos. Eliminar los datos de tipo string y dejar solamente los datos númericos.")
lista = [1, "2", 3.5, "4", 5]
print(lista)
for i in lista:
    if type(i) == str:
        lista.remove(i)

print(lista)